// Tencent is pleased to support the open source community by making tRPC available.
// Copyright (C) 2023 THL A29 Limited, a Tencent company. All rights reserved.
// If you have downloaded a copy of the tRPC source code from Tencent,
// please note that tRPC source code is licensed under the Apache 2.0 License that can be found in the LICENSE file.

// Code generated by trpc-go/trpc-cmdline v2.0.13. DO NOT EDIT.
// source: test.proto

package protocols

import (
	"context"
	"fmt"

	_ "trpc.group/trpc-go/trpc-go"
	"trpc.group/trpc-go/trpc-go/client"
	"trpc.group/trpc-go/trpc-go/codec"
	_ "trpc.group/trpc-go/trpc-go/http"
	"trpc.group/trpc-go/trpc-go/restful"
	"trpc.group/trpc-go/trpc-go/server"
	"trpc.group/trpc-go/trpc-go/stream"
)

/* ************************************ Service Definition ************************************ */

// TestTRPCService defines service
type TestTRPCService interface {

	// EmptyCall One empty request followed by one empty response.
	EmptyCall(ctx context.Context, req *Empty) (*Empty, error)

	// UnaryCall One request followed by one response.
	//  The server returns the client payload as-is.
	UnaryCall(ctx context.Context, req *SimpleRequest) (*SimpleResponse, error)
}

func TestTRPCService_EmptyCall_Handler(svr interface{}, ctx context.Context, f server.FilterFunc) (interface{}, error) {
	req := &Empty{}
	filters, err := f(req)
	if err != nil {
		return nil, err
	}
	handleFunc := func(ctx context.Context, reqBody interface{}) (interface{}, error) {
		return svr.(TestTRPCService).EmptyCall(ctx, reqBody.(*Empty))
	}

	var rsp interface{}
	rsp, err = filters.Filter(ctx, req, handleFunc)
	if err != nil {
		return nil, err
	}

	return rsp, nil
}

func TestTRPCService_UnaryCall_Handler(svr interface{}, ctx context.Context, f server.FilterFunc) (interface{}, error) {
	req := &SimpleRequest{}
	filters, err := f(req)
	if err != nil {
		return nil, err
	}
	handleFunc := func(ctx context.Context, reqBody interface{}) (interface{}, error) {
		return svr.(TestTRPCService).UnaryCall(ctx, reqBody.(*SimpleRequest))
	}

	var rsp interface{}
	rsp, err = filters.Filter(ctx, req, handleFunc)
	if err != nil {
		return nil, err
	}

	return rsp, nil
}

// TestTRPCServer_ServiceDesc descriptor for server.RegisterService
var TestTRPCServer_ServiceDesc = server.ServiceDesc{
	ServiceName: "trpc.testing.end2end.TestTRPC",
	HandlerType: ((*TestTRPCService)(nil)),
	Methods: []server.Method{
		{
			Name: "/trpc.testing.end2end.TestTRPC/EmptyCall",
			Func: TestTRPCService_EmptyCall_Handler,
		},
		{
			Name: "/trpc.testing.end2end.TestTRPC/UnaryCall",
			Func: TestTRPCService_UnaryCall_Handler,
		},
	},
}

// RegisterTestTRPCService register service
func RegisterTestTRPCService(s server.Service, svr TestTRPCService) {
	if err := s.Register(&TestTRPCServer_ServiceDesc, svr); err != nil {
		panic(fmt.Sprintf("TestTRPC register error:%v", err))
	}

}

// TestStreamingService defines service
type TestStreamingService interface {

	// StreamingOutputCall One request followed by a sequence of responses (streamed download).
	//  The server returns the payload with client desired type and sizes.
	StreamingOutputCall(*StreamingOutputCallRequest, TestStreaming_StreamingOutputCallServer) error

	// StreamingInputCall A sequence of requests followed by one response (streamed upload).
	//  The server returns the aggregated size of client payload as the result.
	StreamingInputCall(TestStreaming_StreamingInputCallServer) error

	// FullDuplexCall A sequence of requests with each request served by the server immediately.
	//  As one request could lead to multiple responses, this interface
	//  demonstrates the idea of full duplexing.
	FullDuplexCall(TestStreaming_FullDuplexCallServer) error

	// HalfDuplexCall A sequence of requests followed by a sequence of responses.
	//  The server buffers all the client requests and then serves them in order. A
	//  stream of responses are returned to the client when the server starts with
	//  first request.
	HalfDuplexCall(TestStreaming_HalfDuplexCallServer) error
}

func TestStreamingService_StreamingOutputCall_Handler(srv interface{}, stream server.Stream) error {
	m := new(StreamingOutputCallRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TestStreamingService).StreamingOutputCall(m, &testStreamingStreamingOutputCallServer{stream})
}

type TestStreaming_StreamingOutputCallServer interface {
	Send(*StreamingOutputCallResponse) error
	server.Stream
}

type testStreamingStreamingOutputCallServer struct {
	server.Stream
}

func (x *testStreamingStreamingOutputCallServer) Send(m *StreamingOutputCallResponse) error {
	return x.Stream.SendMsg(m)
}

func TestStreamingService_StreamingInputCall_Handler(srv interface{}, stream server.Stream) error {
	return srv.(TestStreamingService).StreamingInputCall(&testStreamingStreamingInputCallServer{stream})
}

type TestStreaming_StreamingInputCallServer interface {
	SendAndClose(*StreamingInputCallResponse) error
	Recv() (*StreamingInputCallRequest, error)
	server.Stream
}

type testStreamingStreamingInputCallServer struct {
	server.Stream
}

func (x *testStreamingStreamingInputCallServer) SendAndClose(m *StreamingInputCallResponse) error {
	return x.Stream.SendMsg(m)
}

func (x *testStreamingStreamingInputCallServer) Recv() (*StreamingInputCallRequest, error) {
	m := new(StreamingInputCallRequest)
	if err := x.Stream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func TestStreamingService_FullDuplexCall_Handler(srv interface{}, stream server.Stream) error {
	return srv.(TestStreamingService).FullDuplexCall(&testStreamingFullDuplexCallServer{stream})
}

type TestStreaming_FullDuplexCallServer interface {
	Send(*StreamingOutputCallResponse) error
	Recv() (*StreamingOutputCallRequest, error)
	server.Stream
}

type testStreamingFullDuplexCallServer struct {
	server.Stream
}

func (x *testStreamingFullDuplexCallServer) Send(m *StreamingOutputCallResponse) error {
	return x.Stream.SendMsg(m)
}

func (x *testStreamingFullDuplexCallServer) Recv() (*StreamingOutputCallRequest, error) {
	m := new(StreamingOutputCallRequest)
	if err := x.Stream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func TestStreamingService_HalfDuplexCall_Handler(srv interface{}, stream server.Stream) error {
	return srv.(TestStreamingService).HalfDuplexCall(&testStreamingHalfDuplexCallServer{stream})
}

type TestStreaming_HalfDuplexCallServer interface {
	Send(*StreamingOutputCallResponse) error
	Recv() (*StreamingOutputCallRequest, error)
	server.Stream
}

type testStreamingHalfDuplexCallServer struct {
	server.Stream
}

func (x *testStreamingHalfDuplexCallServer) Send(m *StreamingOutputCallResponse) error {
	return x.Stream.SendMsg(m)
}

func (x *testStreamingHalfDuplexCallServer) Recv() (*StreamingOutputCallRequest, error) {
	m := new(StreamingOutputCallRequest)
	if err := x.Stream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TestStreamingServer_ServiceDesc descriptor for server.RegisterService
var TestStreamingServer_ServiceDesc = server.ServiceDesc{
	ServiceName:  "trpc.testing.end2end.TestStreaming",
	HandlerType:  ((*TestStreamingService)(nil)),
	StreamHandle: stream.NewStreamDispatcher(),
	Methods:      []server.Method{},
	Streams: []server.StreamDesc{
		{
			StreamName:    "/trpc.testing.end2end.TestStreaming/StreamingOutputCall",
			Handler:       TestStreamingService_StreamingOutputCall_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "/trpc.testing.end2end.TestStreaming/StreamingInputCall",
			Handler:       TestStreamingService_StreamingInputCall_Handler,
			ServerStreams: false,
		},
		{
			StreamName:    "/trpc.testing.end2end.TestStreaming/FullDuplexCall",
			Handler:       TestStreamingService_FullDuplexCall_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "/trpc.testing.end2end.TestStreaming/HalfDuplexCall",
			Handler:       TestStreamingService_HalfDuplexCall_Handler,
			ServerStreams: true,
		},
	},
}

// RegisterTestStreamingService register service
func RegisterTestStreamingService(s server.Service, svr TestStreamingService) {
	if err := s.Register(&TestStreamingServer_ServiceDesc, svr); err != nil {
		panic(fmt.Sprintf("TestStreaming register error:%v", err))
	}

}

// TestHTTPService defines service
type TestHTTPService interface {
	UnaryCall(ctx context.Context, req *SimpleRequest) (*SimpleResponse, error)
}

func TestHTTPService_UnaryCall_Handler(svr interface{}, ctx context.Context, f server.FilterFunc) (interface{}, error) {
	req := &SimpleRequest{}
	filters, err := f(req)
	if err != nil {
		return nil, err
	}
	handleFunc := func(ctx context.Context, reqBody interface{}) (interface{}, error) {
		return svr.(TestHTTPService).UnaryCall(ctx, reqBody.(*SimpleRequest))
	}

	var rsp interface{}
	rsp, err = filters.Filter(ctx, req, handleFunc)
	if err != nil {
		return nil, err
	}

	return rsp, nil
}

// TestHTTPServer_ServiceDesc descriptor for server.RegisterService
var TestHTTPServer_ServiceDesc = server.ServiceDesc{
	ServiceName: "trpc.testing.end2end.TestHTTP",
	HandlerType: ((*TestHTTPService)(nil)),
	Methods: []server.Method{
		{
			Name: "/UnaryCall",
			Func: TestHTTPService_UnaryCall_Handler,
		},
		{
			Name: "/trpc.testing.end2end.TestHTTP/UnaryCall",
			Func: TestHTTPService_UnaryCall_Handler,
		},
	},
}

// RegisterTestHTTPService register service
func RegisterTestHTTPService(s server.Service, svr TestHTTPService) {
	if err := s.Register(&TestHTTPServer_ServiceDesc, svr); err != nil {
		panic(fmt.Sprintf("TestHTTP register error:%v", err))
	}

}

// TestRESTfulService defines service
type TestRESTfulService interface {
	UnaryCall(ctx context.Context, req *SimpleRequest) (*SimpleResponse, error)
}

func TestRESTfulService_UnaryCall_Handler(svr interface{}, ctx context.Context, f server.FilterFunc) (interface{}, error) {
	req := &SimpleRequest{}
	filters, err := f(req)
	if err != nil {
		return nil, err
	}
	handleFunc := func(ctx context.Context, reqBody interface{}) (interface{}, error) {
		return svr.(TestRESTfulService).UnaryCall(ctx, reqBody.(*SimpleRequest))
	}

	var rsp interface{}
	rsp, err = filters.Filter(ctx, req, handleFunc)
	if err != nil {
		return nil, err
	}

	return rsp, nil
}

// requestBodyTestRESTfulServiceUnaryCallRESTfulPath0 POST: /UnaryCall
type requestBodyTestRESTfulServiceUnaryCallRESTfulPath0 struct{}

func (requestBodyTestRESTfulServiceUnaryCallRESTfulPath0) Locate(message restful.ProtoMessage) interface{} {
	x := message.(*SimpleRequest)
	return x
}

func (requestBodyTestRESTfulServiceUnaryCallRESTfulPath0) Body() string {
	return "*"
}

// TestRESTfulServer_ServiceDesc descriptor for server.RegisterService
var TestRESTfulServer_ServiceDesc = server.ServiceDesc{
	ServiceName: "trpc.testing.end2end.TestRESTful",
	HandlerType: ((*TestRESTfulService)(nil)),
	Methods: []server.Method{
		{
			Name: "/trpc.testing.end2end.TestRESTful/UnaryCall",
			Func: TestRESTfulService_UnaryCall_Handler,
			Bindings: []*restful.Binding{{
				Name:  "/trpc.testing.end2end.TestRESTful/UnaryCall",
				Input: func() restful.ProtoMessage { return new(SimpleRequest) },
				Filter: func(svc interface{}, ctx context.Context, reqBody interface{}) (interface{}, error) {
					return svc.(TestRESTfulService).UnaryCall(ctx, reqBody.(*SimpleRequest))
				},
				HTTPMethod:   "POST",
				Pattern:      restful.Enforce("/UnaryCall"),
				Body:         requestBodyTestRESTfulServiceUnaryCallRESTfulPath0{},
				ResponseBody: nil,
			}, {
				Name:  "/trpc.testing.end2end.TestRESTful/UnaryCall",
				Input: func() restful.ProtoMessage { return new(SimpleRequest) },
				Filter: func(svc interface{}, ctx context.Context, reqBody interface{}) (interface{}, error) {
					return svc.(TestRESTfulService).UnaryCall(ctx, reqBody.(*SimpleRequest))
				},
				HTTPMethod:   "GET",
				Pattern:      restful.Enforce("/UnaryCall/{username}"),
				Body:         nil,
				ResponseBody: nil,
			}},
		},
	},
}

// RegisterTestRESTfulService register service
func RegisterTestRESTfulService(s server.Service, svr TestRESTfulService) {
	if err := s.Register(&TestRESTfulServer_ServiceDesc, svr); err != nil {
		panic(fmt.Sprintf("TestRESTful register error:%v", err))
	}

}

/* ************************************ Client Definition ************************************ */

// TestTRPCClientProxy defines service client proxy
type TestTRPCClientProxy interface {
	// EmptyCall One empty request followed by one empty response.
	EmptyCall(ctx context.Context, req *Empty, opts ...client.Option) (rsp *Empty, err error)

	// UnaryCall One request followed by one response.
	//  The server returns the client payload as-is.
	UnaryCall(ctx context.Context, req *SimpleRequest, opts ...client.Option) (rsp *SimpleResponse, err error)
}

type TestTRPCClientProxyImpl struct {
	client       client.Client
	streamClient stream.Client
	opts         []client.Option
}

var NewTestTRPCClientProxy = func(opts ...client.Option) TestTRPCClientProxy {
	return &TestTRPCClientProxyImpl{client: client.DefaultClient, streamClient: stream.DefaultStreamClient, opts: opts}
}

func (c *TestTRPCClientProxyImpl) EmptyCall(ctx context.Context, req *Empty, opts ...client.Option) (*Empty, error) {
	ctx, msg := codec.WithCloneMessage(ctx)
	defer codec.PutBackMessage(msg)

	msg.WithClientRPCName("/trpc.testing.end2end.TestTRPC/EmptyCall")
	msg.WithCalleeServiceName(TestTRPCServer_ServiceDesc.ServiceName)
	msg.WithCalleeApp("testing")
	msg.WithCalleeServer("end2end")
	msg.WithCalleeService("TestTRPC")
	msg.WithCalleeMethod("EmptyCall")
	msg.WithSerializationType(codec.SerializationTypePB)

	callopts := make([]client.Option, 0, len(c.opts)+len(opts))
	callopts = append(callopts, c.opts...)
	callopts = append(callopts, opts...)

	rsp := &Empty{}

	if err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {
		return nil, err
	}

	return rsp, nil
}

func (c *TestTRPCClientProxyImpl) UnaryCall(ctx context.Context, req *SimpleRequest, opts ...client.Option) (*SimpleResponse, error) {
	ctx, msg := codec.WithCloneMessage(ctx)
	defer codec.PutBackMessage(msg)

	msg.WithClientRPCName("/trpc.testing.end2end.TestTRPC/UnaryCall")
	msg.WithCalleeServiceName(TestTRPCServer_ServiceDesc.ServiceName)
	msg.WithCalleeApp("testing")
	msg.WithCalleeServer("end2end")
	msg.WithCalleeService("TestTRPC")
	msg.WithCalleeMethod("UnaryCall")
	msg.WithSerializationType(codec.SerializationTypePB)

	callopts := make([]client.Option, 0, len(c.opts)+len(opts))
	callopts = append(callopts, c.opts...)
	callopts = append(callopts, opts...)

	rsp := &SimpleResponse{}

	if err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {
		return nil, err
	}

	return rsp, nil
}

// TestStreamingClientProxy defines service client proxy
type TestStreamingClientProxy interface {
	// StreamingOutputCall One request followed by a sequence of responses (streamed download).
	//  The server returns the payload with client desired type and sizes.
	StreamingOutputCall(ctx context.Context, req *StreamingOutputCallRequest, opts ...client.Option) (TestStreaming_StreamingOutputCallClient, error)

	// StreamingInputCall A sequence of requests followed by one response (streamed upload).
	//  The server returns the aggregated size of client payload as the result.
	StreamingInputCall(ctx context.Context, opts ...client.Option) (TestStreaming_StreamingInputCallClient, error)

	// FullDuplexCall A sequence of requests with each request served by the server immediately.
	//  As one request could lead to multiple responses, this interface
	//  demonstrates the idea of full duplexing.
	FullDuplexCall(ctx context.Context, opts ...client.Option) (TestStreaming_FullDuplexCallClient, error)

	// HalfDuplexCall A sequence of requests followed by a sequence of responses.
	//  The server buffers all the client requests and then serves them in order. A
	//  stream of responses are returned to the client when the server starts with
	//  first request.
	HalfDuplexCall(ctx context.Context, opts ...client.Option) (TestStreaming_HalfDuplexCallClient, error)
}

type TestStreamingClientProxyImpl struct {
	client       client.Client
	streamClient stream.Client
	opts         []client.Option
}

var NewTestStreamingClientProxy = func(opts ...client.Option) TestStreamingClientProxy {
	return &TestStreamingClientProxyImpl{client: client.DefaultClient, streamClient: stream.DefaultStreamClient, opts: opts}
}

func (c *TestStreamingClientProxyImpl) StreamingOutputCall(ctx context.Context, req *StreamingOutputCallRequest, opts ...client.Option) (TestStreaming_StreamingOutputCallClient, error) {
	ctx, msg := codec.WithCloneMessage(ctx)

	msg.WithClientRPCName("/trpc.testing.end2end.TestStreaming/StreamingOutputCall")
	msg.WithCalleeServiceName(TestStreamingServer_ServiceDesc.ServiceName)
	msg.WithCalleeApp("testing")
	msg.WithCalleeServer("end2end")
	msg.WithCalleeService("TestStreaming")
	msg.WithCalleeMethod("StreamingOutputCall")
	msg.WithSerializationType(codec.SerializationTypePB)

	clientStreamDesc := &client.ClientStreamDesc{}
	clientStreamDesc.StreamName = "/trpc.testing.end2end.TestStreaming/StreamingOutputCall"
	clientStreamDesc.ClientStreams = false
	clientStreamDesc.ServerStreams = true

	callopts := make([]client.Option, 0, len(c.opts)+len(opts))
	callopts = append(callopts, c.opts...)
	callopts = append(callopts, opts...)

	stream, err := c.streamClient.NewStream(ctx, clientStreamDesc, "/trpc.testing.end2end.TestStreaming/StreamingOutputCall", callopts...)
	if err != nil {
		return nil, err
	}
	x := &testStreamingStreamingOutputCallClient{stream}
	if err := x.ClientStream.SendMsg(req); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}

	return x, nil
}

type TestStreaming_StreamingOutputCallClient interface {
	Recv() (*StreamingOutputCallResponse, error)
	client.ClientStream
}

type testStreamingStreamingOutputCallClient struct {
	client.ClientStream
}

func (x *testStreamingStreamingOutputCallClient) Recv() (*StreamingOutputCallResponse, error) {
	m := new(StreamingOutputCallResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *TestStreamingClientProxyImpl) StreamingInputCall(ctx context.Context, opts ...client.Option) (TestStreaming_StreamingInputCallClient, error) {
	ctx, msg := codec.WithCloneMessage(ctx)

	msg.WithClientRPCName("/trpc.testing.end2end.TestStreaming/StreamingInputCall")
	msg.WithCalleeServiceName(TestStreamingServer_ServiceDesc.ServiceName)
	msg.WithCalleeApp("testing")
	msg.WithCalleeServer("end2end")
	msg.WithCalleeService("TestStreaming")
	msg.WithCalleeMethod("StreamingInputCall")
	msg.WithSerializationType(codec.SerializationTypePB)

	clientStreamDesc := &client.ClientStreamDesc{}
	clientStreamDesc.StreamName = "/trpc.testing.end2end.TestStreaming/StreamingInputCall"
	clientStreamDesc.ClientStreams = true
	clientStreamDesc.ServerStreams = false

	callopts := make([]client.Option, 0, len(c.opts)+len(opts))
	callopts = append(callopts, c.opts...)
	callopts = append(callopts, opts...)

	stream, err := c.streamClient.NewStream(ctx, clientStreamDesc, "/trpc.testing.end2end.TestStreaming/StreamingInputCall", callopts...)
	if err != nil {
		return nil, err
	}
	x := &testStreamingStreamingInputCallClient{stream}

	return x, nil
}

type TestStreaming_StreamingInputCallClient interface {
	Send(*StreamingInputCallRequest) error
	CloseAndRecv() (*StreamingInputCallResponse, error)
	client.ClientStream
}

type testStreamingStreamingInputCallClient struct {
	client.ClientStream
}

func (x *testStreamingStreamingInputCallClient) Send(m *StreamingInputCallRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *testStreamingStreamingInputCallClient) CloseAndRecv() (*StreamingInputCallResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(StreamingInputCallResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *TestStreamingClientProxyImpl) FullDuplexCall(ctx context.Context, opts ...client.Option) (TestStreaming_FullDuplexCallClient, error) {
	ctx, msg := codec.WithCloneMessage(ctx)

	msg.WithClientRPCName("/trpc.testing.end2end.TestStreaming/FullDuplexCall")
	msg.WithCalleeServiceName(TestStreamingServer_ServiceDesc.ServiceName)
	msg.WithCalleeApp("testing")
	msg.WithCalleeServer("end2end")
	msg.WithCalleeService("TestStreaming")
	msg.WithCalleeMethod("FullDuplexCall")
	msg.WithSerializationType(codec.SerializationTypePB)

	clientStreamDesc := &client.ClientStreamDesc{}
	clientStreamDesc.StreamName = "/trpc.testing.end2end.TestStreaming/FullDuplexCall"
	clientStreamDesc.ClientStreams = true
	clientStreamDesc.ServerStreams = true

	callopts := make([]client.Option, 0, len(c.opts)+len(opts))
	callopts = append(callopts, c.opts...)
	callopts = append(callopts, opts...)

	stream, err := c.streamClient.NewStream(ctx, clientStreamDesc, "/trpc.testing.end2end.TestStreaming/FullDuplexCall", callopts...)
	if err != nil {
		return nil, err
	}
	x := &testStreamingFullDuplexCallClient{stream}

	return x, nil
}

type TestStreaming_FullDuplexCallClient interface {
	Send(*StreamingOutputCallRequest) error
	Recv() (*StreamingOutputCallResponse, error)
	client.ClientStream
}

type testStreamingFullDuplexCallClient struct {
	client.ClientStream
}

func (x *testStreamingFullDuplexCallClient) Send(m *StreamingOutputCallRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *testStreamingFullDuplexCallClient) Recv() (*StreamingOutputCallResponse, error) {
	m := new(StreamingOutputCallResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *TestStreamingClientProxyImpl) HalfDuplexCall(ctx context.Context, opts ...client.Option) (TestStreaming_HalfDuplexCallClient, error) {
	ctx, msg := codec.WithCloneMessage(ctx)

	msg.WithClientRPCName("/trpc.testing.end2end.TestStreaming/HalfDuplexCall")
	msg.WithCalleeServiceName(TestStreamingServer_ServiceDesc.ServiceName)
	msg.WithCalleeApp("testing")
	msg.WithCalleeServer("end2end")
	msg.WithCalleeService("TestStreaming")
	msg.WithCalleeMethod("HalfDuplexCall")
	msg.WithSerializationType(codec.SerializationTypePB)

	clientStreamDesc := &client.ClientStreamDesc{}
	clientStreamDesc.StreamName = "/trpc.testing.end2end.TestStreaming/HalfDuplexCall"
	clientStreamDesc.ClientStreams = true
	clientStreamDesc.ServerStreams = true

	callopts := make([]client.Option, 0, len(c.opts)+len(opts))
	callopts = append(callopts, c.opts...)
	callopts = append(callopts, opts...)

	stream, err := c.streamClient.NewStream(ctx, clientStreamDesc, "/trpc.testing.end2end.TestStreaming/HalfDuplexCall", callopts...)
	if err != nil {
		return nil, err
	}
	x := &testStreamingHalfDuplexCallClient{stream}

	return x, nil
}

type TestStreaming_HalfDuplexCallClient interface {
	Send(*StreamingOutputCallRequest) error
	Recv() (*StreamingOutputCallResponse, error)
	client.ClientStream
}

type testStreamingHalfDuplexCallClient struct {
	client.ClientStream
}

func (x *testStreamingHalfDuplexCallClient) Send(m *StreamingOutputCallRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *testStreamingHalfDuplexCallClient) Recv() (*StreamingOutputCallResponse, error) {
	m := new(StreamingOutputCallResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TestHTTPClientProxy defines service client proxy
type TestHTTPClientProxy interface {
	UnaryCall(ctx context.Context, req *SimpleRequest, opts ...client.Option) (rsp *SimpleResponse, err error)
}

type TestHTTPClientProxyImpl struct {
	client       client.Client
	streamClient stream.Client
	opts         []client.Option
}

var NewTestHTTPClientProxy = func(opts ...client.Option) TestHTTPClientProxy {
	return &TestHTTPClientProxyImpl{client: client.DefaultClient, streamClient: stream.DefaultStreamClient, opts: opts}
}

func (c *TestHTTPClientProxyImpl) UnaryCall(ctx context.Context, req *SimpleRequest, opts ...client.Option) (*SimpleResponse, error) {
	ctx, msg := codec.WithCloneMessage(ctx)
	defer codec.PutBackMessage(msg)

	msg.WithClientRPCName("/UnaryCall")
	msg.WithCalleeServiceName(TestHTTPServer_ServiceDesc.ServiceName)
	msg.WithCalleeApp("testing")
	msg.WithCalleeServer("end2end")
	msg.WithCalleeService("TestHTTP")
	msg.WithCalleeMethod("UnaryCall")
	msg.WithSerializationType(codec.SerializationTypePB)

	callopts := make([]client.Option, 0, len(c.opts)+len(opts))
	callopts = append(callopts, c.opts...)
	callopts = append(callopts, opts...)

	rsp := &SimpleResponse{}

	if err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {
		return nil, err
	}

	return rsp, nil
}

// TestRESTfulClientProxy defines service client proxy
type TestRESTfulClientProxy interface {
	UnaryCall(ctx context.Context, req *SimpleRequest, opts ...client.Option) (rsp *SimpleResponse, err error)
}

type TestRESTfulClientProxyImpl struct {
	client       client.Client
	streamClient stream.Client
	opts         []client.Option
}

var NewTestRESTfulClientProxy = func(opts ...client.Option) TestRESTfulClientProxy {
	return &TestRESTfulClientProxyImpl{client: client.DefaultClient, streamClient: stream.DefaultStreamClient, opts: opts}
}

func (c *TestRESTfulClientProxyImpl) UnaryCall(ctx context.Context, req *SimpleRequest, opts ...client.Option) (*SimpleResponse, error) {
	ctx, msg := codec.WithCloneMessage(ctx)
	defer codec.PutBackMessage(msg)

	msg.WithClientRPCName("/trpc.testing.end2end.TestRESTful/UnaryCall")
	msg.WithCalleeServiceName(TestRESTfulServer_ServiceDesc.ServiceName)
	msg.WithCalleeApp("testing")
	msg.WithCalleeServer("end2end")
	msg.WithCalleeService("TestRESTful")
	msg.WithCalleeMethod("UnaryCall")
	msg.WithSerializationType(codec.SerializationTypePB)

	callopts := make([]client.Option, 0, len(c.opts)+len(opts))
	callopts = append(callopts, c.opts...)
	callopts = append(callopts, opts...)

	rsp := &SimpleResponse{}

	if err := c.client.Invoke(ctx, req, rsp, callopts...); err != nil {
		return nil, err
	}

	return rsp, nil
}
